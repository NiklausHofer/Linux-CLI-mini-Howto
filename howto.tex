\documentclass[10pt,paper=a4,final]{scrartcl}
% For good explanations and exaples, go here: http://en.wikibooks.org/wiki/LaTeX
\usepackage[utf8]{inputenc}	%Allow german umlaute
\usepackage{tabularx}		%used for the tables
\usepackage{geometry}		%allows us to specify the 'seitenrand'
\usepackage[table]{xcolor}	%allows us to make colored fields in the tables
\usepackage{graphicx}		%package used to include graphics
\usepackage{hyperref}   		%used to make klickable links
\usepackage{pdflscape}		%allows landscape mode
\usepackage{listings}
\usepackage{courier}

\lstset{
  language=C,
  basicstyle=\ttfamily,
  commentstyle=\ttfamily,
  showspaces=false
}
\lstdefinestyle{Shell}{delim=[il][\bfseries]{BB}}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\lstset{
  backgroundcolor=\color{lightgray}
}

\setcounter{tocdepth}{5}        	%include everything, including subparagraph in tableofcontents
\setcounter{secnumdepth}{5}     %also number the paragraphs

%\hypersetup{linktocpage}	%make the tableofcontent klickable
\hypersetup{
  colorlinks,
  citecolor=black,
  filecolor=black,
  linkcolor=black,
  urlcolor=black
}

%These two lines will allow us to specify our own headers/footers
\usepackage{fancyhdr}
\pagestyle{fancy}
 \setlength{\parskip}{0pt}
 \setlength{\baselineskip}{0pt}

%The next three lines set the default font to Arial
%use 'getnonfreefonts arial-urw' to install uarial on Linux systems
%\usepackage[T1]{fontenc}
%\usepackage[scaled]{uarial}
%\renewcommand*\familydefault{\sfdefault}

% Seitenrand will be 2cm on all four sides
\geometry{a4paper, top=20mm, right=20mm, bottom=20mm, left=20mm}
% Set the document title here:
\title{Linux CLI mini Howto}
%set the authors here
\author{Niklaus Hofer}
\date{\today}

%defining header and footer
\fancyhf{}	%delete default values
\setlength{\headwidth}{\textwidth}	%header and footer width equal the text width
\fancyhead[LE,LO]{}
\fancyhead[RE,RO]{Linux CLI mini Howto}
\fancyfoot[CE,CO]{Speicherdatum: \today{}}
\fancyfoot[RE,RO]{\thepage}

\begin{document}
%make a title page with the title and authors set above
\maketitle
\newpage
% linksbuendig anstatt Blocksatz
\flushleft
%table of contents
\tableofcontents
\newpage
\include{einfuehrung}
\include{allgemeines}
\include{moving_on_the_filesystem}
\include{dateien}
\include{archiv_formate}


\section{virtuelle Dateisysteme in /dev und einige hacks dazu}
Unter Linux sind alle am Computer angeh\"angten Ger\"ate unter /dev aufgef\"hrt. Meistens greift der Nutzer nicht auf Dateien in /dev zu. Es gibt aber einige Ausnahmen. Die wichtigste sind die virtuellen Dateisysteme /dev/zero /dev/null und /dev/random.\\
\begin{itemize}
\item /dev/zero ist ein virtuelles Dateisystem, das immer Nullen zur\"uckgibt
\item /dev/null ist ein virtuelles Dateisystem, in das sich unbegrenzt viele Daten schreiben lassen. Diese werden dabei aber nicht gespeichert, sondern ins Nirvana geschickt.
\item /dev/random liefert zuf\"allige Werte zur\"uck. Die Zufallswerte von /dev/random haben eine sehr hohe kryptografische Qualit\"at sind aber aufwenig zu erzeugen und f\"ur grosse Schreiboperationen wie das \"Uberschreiben einer Festplatte nicht geeignet. Vielmehr sind si zu verwenden wenn hohe kryptografische Anspr\"uche gestellt werden wie beim Erstellen eines keys.
\item /dev/urandom /dev/urandom liefert ebenfalls Zufallswerte, allerdings mit weniger hoher Qualit\"at, daf\"ur schneller. Die Werte sind aber immer noch als stark zu betrachten und gen\"ugen f\"ur die meisten Aufgaben.
\end{itemize}
Hier einige Anwendungszwechek f\"ur diese virtuellen Devices:
\begin{description}
\item[Output umleiten] \hfill \\
Wird ein Programm in der Konsole gestartet, so gibt es von Zeit zu Zeit Output zur\"uck. M\"ochte man aber in der gleichen Konsole weiterarbeiten kann das l\"astig sein. Der Output kann deshalb nach /dev/null umgeleitet werden. Zudem k\"onnen Fehlermeldunen wahlweise ebenfalls oder eben nicht umgeleitet werden.
\begin{lstlisting}[frame=single]
# Umleiten des outputs
dhcpd > /dev/null &
# Umleitung der output und der Fehlermeldungen
dhcpd > /dev/null 2> /dev/null &
\end{lstlisting}
\item[Erstellen einer beliebig grossen Testdatei] \hfill \\
Eine beliebig grosse Testdatei kann mit dd und wahlweise /dev/zero oder /dev/urandom generiert werden. Eine solche Datei kann zum Beispiel zum Messen der Performance einer Anwendung verwendet werden. ACHTUNG: In diesem Beispiel wird dd verwendet. dd tut genau das, wozu es angewiesen wird. Wird ihm, aus Versehen oder willentlich, gesagt ben MBR der Systemplatte zu \"uberschreiben, so tut es das! Es ist deshalb Vorsicht geboten.
\begin{lstlisting}[frame=single]
# create a 512MB testfile with random data
dd if=/dev/urandom of=~/testfile bs=1M count=512
\end{lstlisting}
\item[\"Uberschreiben des MBR] \hfill \\
Der 512byte grosse Bootsektor l\"asst sich einfach mit Nullen \"uberschreiben. Dadurch verschwindet die Partitionstabelle und der Bootloader.
\begin{lstlisting}[frame=single]
# MBR der zweiten Festplatte im System
dd if=/dev/zero of=/dev/sdb bs=1 count=512
\end{lstlisting}
\item[\"Uberschreiben einer Festplatte mit Zufallszahlen] \hfill \\
Vor dem Weiterverkauf einer Festplatte sollten alle Daten darauf \"uberschrieben werden, z.B. mit Zufallszahlen.
\begin{lstlisting}[frame=single]
dd if=/dev/urandom of=/dev/sdb bs=1M
\end{lstlisting}
\end{description}

\section{Speichermedien}
Alle Speichermedien die an einem Linux System angeschlossen sind, werden im /dev-Verzeichnis bereitgestellt. Sie sind dort als Dateien vorzufinden. Diese Dateien sind nicht gemounted und jeder Zugriff darauf erfolgt auf bitebene und nicht \"uber das Dateisystem. Befor Dateien auf das Medium geschrieben und davon gelesen werden k\"onnen muss dieses gemounted werden.\\
\subsection{Die Speichermedien in /dev}
Speichermedien werden in /dev mit einem Namen referenziert der sich darauf bezieht in welcher Reihenfolge das Medium mit dem System verbunden wurde.
SATA und USB Speichermedien werden mit sd(a-z) benannt, PATA/IDE Medien mit hd(a-z).\\
Die erste Festplatte im System tr\"agt als den Namen sda und ist unter /dev/sda zu finden.\\
Die Partitionen auf der Platte werden hochgez\"ahlt. Die erste Partition auf der ersten Platte ist sda1, die 5te Partition auf der dritten Platte sdc5. gemounted werden die Partitionen, nicht die Platten selbst.\\
Zudem werden die Partitionen in modernen Linux distributionen mit einer eindeutigen ID, der sogenannten UUID, bezeichnet. Wird zum mounten diese ID verwendet anstatt des sda/hda Namens spielt es keine Rolle in welcher Reihenfolge die Speichermedien mit dem System verbunden wurden. Ubuntu benutzt zum Mounten der Systempartitionen immer die UUIDs. Die Partitionen werden in /dev/disk/by-uuid/ mit ihrere UUID referenziert. Um die UUID einer Partition zu ermitteln kann entweder vol\_id --uuid oder blkid verwendet werden.
\begin{lstlisting}[frame=single]
vol_id --uuid /dev/sda1
72dd0978-e1a1-4dfb-af24-4e3b1eb4b4eb
# blkid zeigt die UUIDs aller Partitionen an
holahp1101 dev # blkid 
/dev/sda2: UUID="4e490597-e033-44f4-9d0c-fc6355358274" TYPE="swap" 
/dev/sda1: UUID="72dd0978-e1a1-4dfb-af24-4e3b1eb4b4eb" TYPE="ext2" 
/dev/sda3: UUID="083cfb51-bcb0-4c5d-98a1-d73a3ffb0935" TYPE="ext4" 
/dev/sda4: UUID="8a8a461c-9f02-4dcc-832c-8c5fc6996f0b" TYPE="ext4" 
/dev/sdb: UUID="7E2C-336F" TYPE="vfat" 
\end{lstlisting}
\subsection{mount}
In Linux kann ein Speichermedium in ein beliebiges Verzeichnis gemounted werden. Ein typisches Beispiel ist /home, das h\"aufig auf einer eigenen Partition liegt. Wenn das die zweite Partition auf der ersten Festplatte ist, so ist /dev/sda2 auf /home gemounted. Ein anderes Beispiel sind die USB Speichermedien die meistens nach /media/<name des speichermediums> gemounted werden.\\
Laufwerke k\"onnen mit dem mount command auch manuell eingeh\"angt werden. Mount kann meistens nur von Root ausgef\"uhrt werden. Um ein Ger\"at zu mounten gen\"ugt
\begin{lstlisting}[frame=single]
# mount medium mountpoint
mount /dev/sdb1 /home
\end{lstlisting}
F\"ur mount gibt es aber auch verschidenen Parameter. -o rw zwingt mount das Dateisystem writable zu mounten (falls irgend m\"oglich), mit -t <type> kann der Typ des Dateisystems angegeben werden.
\begin{lstlisting}[frame=single]
mount -o rw -t ntfs /dev/sdc1 /media/gibbix
# ACHTUNG: das Verzeichnis /media/gibbix muss zuerste erstellt werden.
\end{lstlisting}
Zum Aush\"angen der Partition wird umount verwendet.
\begin{lstlisting}[frame=single]
umount /dev/sdc1
# oder
umount /media/gibbix
\end{lstlisting}
\subsection{automount und pmount}
Distributionen wie Ubuntu h\"angen externe Speichermedien nach der Verbindung mit dem Computer automatisch im /media Verzeichnis ein, so dass sie auch vom Nutzer gelesen werden k\"onnen.\\
Funktioniert das aus irgend einem Grund nicht, so kann man das Device manuell als Root einh\"angen unter Verwendung des mount commands. Das bringt aber einige Nachteile:
\begin{itemize}
\item Das mountverzeichnis unter /media muss zuerst manuell erstellt und am Schluss wieder gel\"oscht werden.
\item handelt es sich um ein FAT/NTFS Dateisystem, so ist der root user danach der einzige der vollen Zugriff darauf hat.
\end{itemize}
Einfacher geht es mit dem tool pmount. Der Befehl
\begin{lstlisting}[frame=single]
pmount /dev/sdc1
\end{lstlisting}
h\"angt sdc1 automatisch in ein passend benanntes Verzeichnis in /media. Dieses wird entweder nach dem Speichermedium benannt (falls dieses einen Namen tr\"agt), oder nach dessen /dev namen (/media/sdc1 oder /media/usbhd-sdc1). Die Zugriffsrechte f\"ur das Ger\"at sind dann automatisch so gesetzt, dass der Nutzer der pumount ausf\"uhrte vollen Zugriff darauf hat. Wird das Verzeichnis per
\begin{lstlisting}[frame=single]
pumount /dev/sdc1
\end{lstlisting}
wieder ausgeh\"angt, so wird der Ordner in /media automatisch wieder gel\"oscht.
\subsection{fstab}
In der Datei /etc/fstab ist definiert welche Partitionen beim Start des Systems automatisch gemounted werden. Mindestens muss dort die Root-Parition (/) gelsited werden. Unter Ubuntu sind die Partitionen in fstab mit ihren UUIDs aufgelisted. F\"ur mehr Details zu fstab verwenden Sie bitte man fstab.

\section{Starting and managing applications and daemons}
\subsection{Applikationen}
\subsubsection{Applikationen im Kontext der aktuellen Shell}
Das Starten eines Programmes aus der Kommandozeile ist denkbar einfach. Bereits ls ist ein Programm das wir starten. Nat\"urlich gibt es auch Programme, die nicht sofort fertig sind. Das k\"onnte sich zum Beispiel um einen Server handeln, den wir laufen lassen.\\
Der Server kann einfach gestartet und laufengelassen werden, indem man den Befehl eintippt. Das hat aber den Nachteil, dass die Shell dann blockiert ist, das der Server darin l\"auft.\\
Ist ein Programm im Vordergrund der Shell am laufen, so erscheint die Prompt nicht mehr und keine neuen Befehle werde akzeptiert. Will man das Programm beenden so sollte man das zuerst durch dr\"ucken von q versuchen. Viele Programme nehmen das als Signal, dass sie stoppen sollen. Funktioniert das nicht, so kann das Programm mit CTRL+C beendet werden.\\
Nat\"urlich k\"onnen wir aber auch ein Programm starten und danach in der gleichen Shell weiterarbeiten. Dazu muss das Programm in den Hintergrund verschoben werden. Um ein Programm gleich nach dem Start in den hintergrund zu verschieben, wird einfach ein Ampersand (\&) hinten an den Befehl geh\"angt. Sofort nach dem Starten des Befehls erscheint dann wieder die Prompt und nimmt neue Befehle entgegen.\\
Auch bereits im Vordergrund gestartete Applikationen k\"onnen in den Hingergrund verschoben werden. Dazu wird zuerste CTRL+Z bedr\"uckt, das Programm wird das Programm wird dann pausiert und die Prompt erscheint wieder. Das pausierte Programm k\"onnen wir nun entweder im Vordergrund oder im Hingergrund weiterlaufen lassen. Dazu verwenden wir de Command fg um das Programm im Vordergrund weiterlaufen zu lassen und bg um es im Hingergrund weiterlaufen zu lassen. Programme, die im Hingergrund laufen k\"onnen sp\"ater mit fg jederzeit wieder in den Vordergrund geholt werden.
\begin{lstlisting}[frame=single]
# mplayer im Hintergrund starten
niklaus@holahp1101:~$ mplayer Music/sound.ogg &
# mplayer im Vordergrund starten, dann in den Hintergrund verschieben
niklaus@holahp1101:~$ mplayer Music/sound.ogg
^Z
niklaus@holahp1101:~$ bg
# mplayer wieder in den Vordergrund holen, dann beenden
niklaus@holahp1101:~$ fg
^C
\end{lstlisting}
Nat\"urlich k\"onnen auch mehrere Programm simultan im Hintergrund laufen. Dann beziehen sich fg und bg jeweils auf die letzte Applikation. Wir k\"onnen aber auch einen bestimmten Task referenzieren. Um zu sehen welche Tasks in unserer Shell laufen brauchen wird den command jobs.\\
jobs zeigt f\"ur jeden in der Shell laufenden Prozess eine ID (die nur in der aktuellen Shell g\"ultig ist!), den Status der Applikation und den genauen command mit dem sie gestartet wurde:
\begin{lstlisting}[frame=single]
niklaus@holahp1101:~$ jobs
[1]+  Stopped                 mplayer 39\ Guten\ Morgen\ Sonnenschein.mp3
[2]   Running                 xterm &
[3]-  Running                 xpdf output.pdf &
\end{lstlisting}
Wir k\"onnen jetzt einen bestimmten Task \"uber seine Nummer referenzieren. Zum schliessen des PDF-Readers xpdf kann wie folgt vorgegangen werden:
\begin{lstlisting}[frame=single]
niklaus@holahp1101:~$ fg 3
xpdf output.pdf
^C
\end{lstlisting}
Startet man Programme in einer Shell im Hintergrund, muss man sich beim Schliessen der Shell gut \"uberlegen, ob die Tasks weiterlaufen sollen. M\"ochte man, dass diese auch nach dem Schliessen der Shell weiterlaufen, so sollte man unbedingt exit verwenden um die Shell zu beenden. Manche terminal emulatoren (darunter auch die popul\"are Gnome-Shell) haben die Angewohnheit alle tasks zu beenden wenn man sie anders als mit exit schliesst.
\subsubsection{Applikationen ausserhalb des Kontexts der aktuellen Shell}
Es ist auch m\"oglich Applikationen zu beenden, die nicht in der aktuellen Shell gestartet wurden, sondern beispielsweise aus einer anderen Shell, von einem anderen Nutzer oder von einem System-Prozess. Beim Schliessen von Tasks anderer Benutzer ist Vorsicht begoten. Zudem kann das je nach Berechtigung des eigenen Nutzer auch nicht funktionieren. Der Root User hat die Macht s\"amtliche Prozesse zu jedem beliebigen Zeitpunkt zu beenden.\\
Um zu sehen welche Prozesse auf dem System laufen, wird ps verwendet. Um alle Prozesse angezeigt zu bekommen werden oft die Parameter -ef verwendet. Manche Nutzer m\"ogen auch -aux anstatt -ef da die Anzeige von -aux eher der von traditionellen UNIX und BSD Systemen gleicht. Ich werde mich im weiteren Verlauf auf -ef beschr\"anken. Hier ist eine gek\"urzte Ausgabe von meinem System:
\begin{lstlisting}[frame=single]
niklaus@holahp1101:~$ ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 09:01 ?        00:00:01 init [3]  
root         2     0  0 09:01 ?        00:00:00 [kthreadd]
root         3     2  0 09:01 ?        00:00:00 [ksoftirqd/0]
root         6     2  0 09:01 ?        00:00:00 [migration/0]
root         7     2  0 09:01 ?        00:00:00 [migration/1]
...
niklaus   2761  2376  0 09:12 ?        00:00:00 /usr/bin/xterm
niklaus   2763  2761  0 09:12 pts/1    00:00:00 bash
niklaus   4708  2376  0 10:26 ?        00:00:00 /usr/bin/xterm
niklaus   4710  4708  0 10:26 pts/2    00:00:00 bash
root      5011  1297  0 10:36 ?        00:00:00 /sbin/udevd --daemon
root      5014  1297  0 10:36 ?        00:00:00 /sbin/udevd --daemon
...
\end{lstlisting}
In der ersten Spalte steht von welchem Nutzer der Prozess gestartet wurde. In der zweiten die PID, die Process ID, \"uber die wir die Applikation ansprechen k\"onnen, in der Dritten die PPID, die PID des parent-processes, zuhinterst steht der Command mit dem der Prozess gestarte wurde.\\
Um eine Applikation zu schliessen steht der kill Befehl zur Verf\"ugung. kill, gefolgt von der PID, 'bittet' die Applikation sich zu beenden. Falls die Applikation nicht darauf reagiert und unbedingt beendet werden soll, so bietet kill den Parameter -9 an. Wird dieser verwendet, wird der Prozess auf der Stelle abgeschossen.
\begin{lstlisting}[frame=single]
# Den Prozess 'bitten' sich selbst zu beenden
niklaus@holahp1101:~$ kill 2763
# Den Prozess abschiessen
niklaus@holahp1101:~$ kill -9 2763
\end{lstlisting}
Um alle tasks zu schliessen, die mit einem bestimmten Command gestartet worden sind, bietet sich killall an.
\begin{lstlisting}[frame=single]
# Beende alle xterms
killall xterm
# Erzwinge das Beenden aller xtems
killall -9 xterm
\end{lstlisting}
Unter Umst\"anden kann die Ausgabe von ps -ef sehr lang werden. Mit Grep k\"onnen wir die Ausgabe nach bestimmten Begriffen durchsuchen und nur die entsprechenden Zeilen anzeigen lassen:
\begin{lstlisting}[frame=single]
niklaus@holahp1101:~$ ps -ef | grep xterm
niklaus   2394  2376  0 09:02 ?        00:00:06 /usr/bin/xterm
niklaus   2761  2376  0 09:12 ?        00:00:00 /usr/bin/xterm
niklaus   4708  2376  0 10:26 ?        00:00:00 /usr/bin/xterm
niklaus  11061  2376  0 14:22 ?        00:00:00 /usr/bin/xterm
niklaus  11111  4710  0 14:23 pts/2    00:00:00 xterm
niklaus  11686  4710  0 14:43 pts/2    00:00:00 grep --colour=auto xterm
# Der letzte Prozess ist unser grep selbst
\end{lstlisting}
Ein weiteres Tool zum suchen von PIDs ist pidof. Pidof nimmt als Parameter den Namen des Programmes das gesucht wird. Anstatt des Programmnamens kann auch der fully qualified Pfad zum Binary angegeben werden (zum Beispiel pidof /bin/bash anstatt pidof bash). Pidof gibt dann die PIDs aller Prozesse dieses Commands zur\"uck. M\"ochte man nur eine einzige PID, so hilft der Parameter -s. Um nicht nur binaries, sondern auch scripts zu beachten, verwendet man den Parameter -x.
\begin{lstlisting}[frame=single]
niklaus@holahp1101:~$ pidof bash
2618 2500 2387
niklaus@holahp1101:~$ pidof -s bash
2618
\end{lstlisting}
\subsection{init Prozesse}
Unter Linux ist jedes Programm ein Prozess und jeder Prozess hat einen Parent Prozess, der ihn gestartet hat. Es gibt keine Ausnahmen! Absolut alles, einschliesslich der grafischen Oberfl\"ache ist ein Prozess. Der oberste Prozess, der als erstes gestartet wurde und der all die anderen initialisiert hat ist init. Init tr\"agt die PID 1.\\
Im Verlauf des Systemstarts startet init weitere inti Prozesse. Start und stop Skripte f\"ur init Prozesse liegen in /etc/init.d. Manchmal ist es notwendig, einen init-daemon neu zu starten. Zum Beispiel wenn die Netzerkkonfiguration neu geschrieben wurde, muss networking neu gestartet werden damit die \"Anderungen angewandt werden. Die init Skripte in /etc/init.d unterst\"utzen die Befehle start, stop und restart. Verwendet werden sie wie folgt:
\begin{lstlisting}[frame=single]
holahp1101 / # /etc/init.d/network restart
 * Stopping network             [ ok ]
 * Starting network 	   	[ ok ]
\end{lstlisting}
Init Skripte k\"onnen nur vom Nutzer root gestartet und gestoppt werden.

\section{Package Management}
\subsection{Idee und Grundlage}
Package Management wurde sehr fr\"uh sehr wichtig f\"ur Linux. Bereits 1998 existierten sehr fortgeschrittene Packet Manager.\\
Moderne Linux Systeme wie Debian, Ubuntu, Fedora, RHEL, SUSE, Mandriva, ... werden komplett vom Packet Manager verwaltet. Ein guter Package manager weiss von jeder Datei auf dem System - die nicht vom Nutzer platziert worden ist - zu welchem Paket sie geh\"ort und welche Programme davon abh\"angen. Jeder Teil des Systems geh\"ort zu einem Paket, inklusive des Linux Kernels und dem Paket Manager selbst!\\
Programme werden in sogenannten Paketen geliefert, die je nach Paketmanager eine anderen Endung haben (.deb f\"ur dpkg, .rpm f\"ur rpm, ...). Das Paket enth\"alt alle Teile der Applikation, ein Script das diese an der richtigen Stelle platziert und konfiguriert. Ausserdem enth\"alt es eine Liste mit Abh\"angigkeiten. Das ist ein, wenn nicht DER, wesentlich Unterschied zum Paketmanagement von Windows und OS X, wo jedes Programm alle Abh\"angigkeiten selbst mitbringt.\\
Paketmanager unter Linux wissen welche Programme von welche abh\"angen. So weiss zum Beispiel dpkg, dass Gnome, GIMP, Pidgin, Evolution, gedit und viele weitere das GTK+ framework ben\"otigen. DPKG installiert GTK+ ein einziges Mal, so dass die Programme, die davon abh\"angen darauf zugreiffen k\"onnen. Die brauchen GTK+ dann nicht mehr selbst mit zu bringen. Dadurch gehen der Download und die Installation eines Programmes unter Linus ofmals wesentlich schneller als unter anderen Systemen. Zudem ben\"otigen Programme wesentlich weniger Platz.\\
Dar\"uberhinaus erkennt er Package manager, wenn ein Programm, das als Abh\"angigkeit eines oder mehrere Anderer isntalliert wurde nicht mehr ben\"otigt wird und kann es entfernen. W\"aren in unserem Beispiel alle GTK+ Applikationen entfernt, so kann der paket manager das GTK+ framework entfernen.\\
Es gibt eine grosse Anzahl von Paketmanagern. Die meist verwendeten sind aber RPM (RedHat Package Manager) und DPKG (Debian Package Manager). Sie beide haben gemein, dass sie nur offline arbeiten und heute eher selten direkt bedient werden. Vielmehr werden sie heute \"uber interfaces bedient, die die Bedienung erleichtern und die Funktionalit\"at erweitern. Bei RPM ist das meistens YUM, bei DPKG apt oder aptitude.\\
Die wichtigste Funktionalit\"at die diese hinzuf\"ugen sind die repositories. Dies sind online verf\"ugbare Ablagen mit, oftmals zehntausenden, von Paketen die f\"ur das System vorkompiliert und verpackt sind. Distributionen haben heuet alle ein Repository standardm\"assig eingestellt. Die Pakete dort sind digital signiert und getestet.\\
Programme wie apt k\"onnen auf Befehl automatisch ein Programm aus dem Repository installieren, die Abh\"angigkeiten aufl\"osen und die weiteren ben\"otigten Abh\"angigkeiten ebenfalls automatisch aus dem Repository laden.\\
Zudem k\"onnen sie im repository nachfragen, zu welchen Applikationen neue Versionen verf\"ugbar sind und diese automatisch installieren. Dadurch ist sichergestellt, das das gesammte System, vom Kernel bis zum grafischen Game, immer auf dem neuesten Stand sind, ohne dass der Entwickler der Applikation etwas daf\"ur tun muss.\\
Wenn immer m\"oglich sollten Programme aus einem Repository installiert werden (meistens ist das auch das einfachste). Einige Programme sind aber nicht in den Standard-repositorien der Distributionen vorhanden, oder nur in veralteten Versionen. Gl\"ucklicherweise k\"onnen die Paketmanager heute aber mehrere Repositorien verbinden. F\"ugt man ein neues Repository manuell hinzu, sollte man zuerst sicher stellen, dass man dem Betreiber vertraut und sollte sichergehen, dass der public key des repositories auf dem eigenen System installiert ist, damit beim Herunterladen von Paketen gepr\"uft wernde kann, dass die Datei nicth manipuliert wurde.\\
Einige Applikationen, die nur nach dem manuellen Download installiert werden k\"onnen, wie Google's Chrome und der Opera browser, richten nach der Installation selbst ein neues Repository ein. Dadurch stellen sie sicher, dass sie \"uber die Systemmechanismen auf dem neuesten Stand gehalten werden, ohne dass sie selbst etwas zu tun brauchen.
\subsection{Ubuntu}
Da ich dieses Dokument f\"ur einen Ubuntu user erstelle, konzentriere ich mich von hier an nur noch auf das Paket management von Ubuntu.
\subsection{dpgk und apt}
Das Paketmanagement von Ubuntu basiert auf dpkg, dem Debian Package Manager. Dieser installiert und verwatet die Pakete mit der .deb Endung.

\subsubsection{apt}

\section{networking}
Desktop Linux distributionen werden heute fast immer mit grafischen Tools zur Konfiguration des Netzwerks ausgeliefert. Am bekanntesten ist der NetworkManager, der sich fast natlos in beliebte Oberfl\"achen wie KDE, Gnome oder XFCE integriert und sehr intuitiv zu bedienen ist - besonders in der k\"urzlich erschienenen Version 0.9. (Ein weiteres, grafisches Tool ist der WICD). Der Networkmanager macht auch das Verbinden mit WLAN und sogar UMTS Netzen sehr einfach.\\
Auf servern sind solche Tools aber nicht verf\"ugbar und auch viele Poweruser bevorzugen auf ihren workstations die traditionelle Netzerkkonfiguration per Textdateien.\\
\subsection{/etc/networks/interfaces}
Ist nichts anderes definiert, so nutzt Linux die Datei /etc/networks/interfaces zur Konfiguration der Netzwerkkarten. Der erste Eintrag in dieser Datei ist meistens lo. Lo steht f\"ur Loopback und beschreibt das Loopback interface das der Rechner zur Kommunikation mit sich selbst verwendet. Dieser Eintrag sollte nicht ver\"andert oder gel\"oscht werden!\\
Danach folgen die Eintr\"age f\"ur die Netzerkkarten. Die erste Physikalische Ethernet-Schnittstelle heisst eth0, bei weiteren wird die Zahl am Ende hochgez\"ahlt. Das erste WLan interface heisst wlan0. Ein Eintrag in der interfaces Datei k\"onnte in etwa so aussehen:
\begin{lstlisting}[frame=single]
# Start eth0 at bootup
auto eth0
# static IP
iface eth0 inet static
	address 192.168.0.100
	netmask 255.255.255.0
	gateway 192.168.0.1
\end{lstlisting}
Dieses Beispiel zeigt die im Minimum erforderlichen Optionen um der Netzwerkkarte eine statische IP zuzuteilen. Die Option auto eth0 definiert hier, dass das Interface eth0 beim Booten des Systems gestartet werden soll. Will man das nicht, so kann diese Zeile einfach weggelassen werden. Der Wert inet besagt, dass wir im Folgenden IPv4 Optionen definieren. Um IPv6 zu konfigurieren kann inet durch inet6 ersetzt werden. Static legt fest, dass eine fixe IP verwendet wird. Die nachfolgenden Optionen erfordern grundlegende Kenntnisse eines IPv4 Netzerkes, sind ansonsten aber selbserkl\"arend.\\
Weitere verf\"ugbare Optionen sind network (in diesem Fall 192.168.0.0) und broadcast (hier 192.168.0.255).\\
Bei Desktop Systemen ist oft die Verwendung von DHCP erw\"unscht. Die Konfiguration daf\"ur ist denkbar einfach:
\begin{lstlisting}[frame=single]
# Start eth0 at bootup
auto eth0
iface eth0 inet dhcp
\end{lstlisting}
Damit das funktioniert, ist nat\"urlich auch in DHCP client n\"otig. Falls noch keiner installiert ist, kann dhclient verwendet werden. DHClient kann mit
\begin{lstlisting}[frame=single]
root@sysem~$ /etc/init.d/dhcpcd start
\end{lstlisting}
gestartet werden. Der daemon l\"asst dann den dhcp client auf allen nicht konfigurierten Interfaces laufen. Je nach Distribution wird auch dhclient verwendet. Um dhclient auf einem bestimmten Interface zu verwenden, ist folgender Befehl zu verwenden.
\begin{lstlisting}[frame=single]
root@system~$ dhclient eth0
\end{lstlisting}
\subsection{resolv.conf}
Abgesehen von der Netzerkkarte muss nat\"urlich auch der DNS Server angegeben werden. Das geschieht \"uber die Datei /etc/resolv.conf, das eine sehr einfache Syntax bietet.
\begin{lstlisting}[frame=single]
nameserver 192.168.0.1
nameserver 8.8.8.8
nameserver 8.8.4.4
\end{lstlisting}
Die aufgelisteten Server werden dabei in der Reihenfolge der Eintragung priorisiert.
\subsection{Netzerk starten}
Ist das Netzwerk fertig konfiguriert, so kann es neu gestartet werden. Damit alle Einstellungen neu eingelesen werden, wird das Networking modul neu gestartet.
\begin{lstlisting}[frame=single]
root@system~$ /etc/init.d/network restart
 * Starting network
\end{lstlisting}
Die Einstellunge k\"onnen jetzt getestet und verwendet werden.
\subsection{ifconfig}
Um die aktuelle Konfiguration einzusehen, wird ifconfig verwendet. Je nach Distribution k\"onnen alle Nutzer oder nur Root ifconfig verwenden. Wird ifconfig ohne weitere Argumente ausgef\"uhrt, so zeigt es die aktuelle Konfiguration aller verf\"ugbaren und gestartetn Netzerkkarten an. Als Parameter kann der Name eines Netzerkinterfaces angegeben werden, dann wird nur dessen Konfiguration angezeigt.
\begin{lstlisting}[frame=single]
root@system~$ ifconfig wlan0
wlan0     Link encap:Ethernet  HWaddr ac:81:12:32:e5:b1  
          inet addr:10.22.53.244  Bcast:10.22.53.255  Mask:255.255.255.0
	  inet6 addr: fe80::ae81:12ff:fe32:e5b1/64 Scope:Link
	  UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:3 errors:0 dropped:0 overruns:0 frame:0
          TX packets:14 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:784 (784.0 B)  TX bytes:2061 (2.0 KiB)
\end{lstlisting}
Ifconfig kennt auch Optionen um das Interface zu konfigurieren. Um die im obigen config file angegebene Konfiguration per ifconfig auf ein Interface anzuwenden kann dieser Befehl verwendet werden:
\begin{lstlisting}[frame=single]
root@system~$ ifconfig eth0 address 192.168.0.100 netmask 255.255.255.0 broadcast 192.168.0.255
root@system~$ ifconfig eth0
eth0      Link encap:Ethernet  HWaddr b4:99:ba:e1:16:0e  
          inet addr:192.168.0.100  Bcast:192.168.0.255  Mask:255.255.255.0
	  ...
\end{lstlisting}
Das broadcast Arguemnt ist dabei Optional, da der Linux networking stack diese auch anhand der IP und netmask berechnen kann. F\"ur weitere Details zu diesen und weiteren Argumenten, referenzieren Sie bitte die ifconfig manpage.\\
Ifconfig kann auch verwendet werden um einzelne Interfaces an oder abzustellen. Dazu werden die Optionen up und down verwendet.\\
\begin{lstlisting}[frame=single]
root@system~$ ifconfig wlan0 down
root@system~$ ifconfig wlan0 up
\end{lstlisting}
\subsection{route}
Der aufmerksame Leser hat nat\"urlich bemerkt (:p), dass wir beim manuellen definieren der Netzerkschnittstelle per ifconfig den default gateway nicht angegeben haben. Dadurch weiss Linux jetzt aber nicht, wie es Hosts und Netzwerke ausserhalb des aktuellen subnets erreichen kann. Die entsprechende Einstellung kann nicht \"uber ifconfig vorgenommen werden. Stattdessen verwenden wir hier den route command. Mit ihm kann die routing table des Systems ausgelesen und manipuliert werden. Es kommt nur selten vor, dass man im allt\"aglichen Gebrauch die Routingtable editieren muss (es sei denn, man arbeite viel mit Netzwerken oder hat ganz bestimmte W\"unsche), und wenn man es doch mal tun muss, so gen\"ugt meistens das setzen der default route. route ohne Argumente zeigt die aktuelle routingtable an:
\begin{lstlisting}[frame=single]
root@system~$ route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
loopback        -               255.0.0.0       !     0      -        0 -
\end{lstlisting}
Hier hat das System noch keine default route. Diese beschreibt, welcher 'Weg' zu nehmen ist, um mit anderne Netzwerken in Kontakt zu treten. Die default route wird immer dann verwendet wenn f\"ur das Ziel-Netzwerk kein anderer Eintrag in der routing table vorhanden ist (also meistens). Meistens ist das einfach die IP des lokalen Routers. Das hinzuf\"ugen einer neuen Route ist denkbar einfach:
\begin{lstlisting}[frame=single]
root@system~$ route add default gw 192.168.0.1
root@system~$ route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         192.168.0.1     0.0.0.0         UG    304    0        0  eth0
loopback        -               255.0.0.0       !     0      -        0 -
\end{lstlisting}
Dieses Ger\"at hier hat zwei Interfaces, ein Ethernet und ein WLAN. Mit route kann ich das System anweisen wlan0 zu nutzen um mit dem Wlan zu kommunizieren und eth0 f\"urs Lan, den default gateway \"uber eth0 haben wir im vorderen Beispiel bereits gesetzt:
\begin{lstlisting}[frame=single]
root@system~$ route add -net 192.168.2.0 netmask 255.255.255.0 dev wlan0
root@system~$ route add -net 192.168.1.0 netmask 255.255.255.0 dev eth0
root@system~$ route
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         192.168.0.1     0.0.0.0         UG    304    0        0  eth0
loopback        -               255.0.0.0       !     0      -        0 -
192.168.1.0     *               255.255.255.0   U     0      0        0 eth0
192.168.2.0     *               255.255.255.0   U     0      0        0 wlan0
\end{lstlisting}
Die route manpage wartet mit vielen weiteren Beispielen und Erl\"auterungen auf.
\subsection{iptables}
IPtables ist eine Applikation um die Paketfilter im Kernel zu definieren. Mithilfe von IPtables kann eine software firewall mit komplexen Regeln definiert werden. Die Beschreibung von IPTables \"ubersteigt den Umfang dieser Dokumentation. Ich merke sie hier nur der Vollsta\"andigkeit halber an.
\subsection{Weitere Netowrking tools}
\subsubsection{host}
Host ist ein einfach zu bedienendes Tool zum Aufl\"osen von Hostnamen in IP Adressen und umgekehrt. Mit der -v Option zeigt der host command noch details zum verwendeten Query an.
\begin{lstlisting}[frame=single]
niklaus@holahp1101:~$ host www.google.com
www.google.com		CNAME	www.l.gogle.com
www.l.google.com	A	74.125.39.103
www.l.google.com	A	74.125.39.99
...
niklaus@holahp1101:~$ host -v 74.125.39.103
Query about 74.125.39.104 for record types PTR
Name: fx-in-f104.1e100.net
Address: 74.125.39.104
\end{lstlisting}
\subsubsection{nslookup}
nslookup kennt zwei Modi: den 'passiven' Modus und einen 'interaktiven'. Im passiven Modus ist nslookup genau gleich zu bedienen wie der host command. Im interaktiven Modus jedoch, bietet nslookup viele weitere Optionen. Um den interaktiven Modus zu starten, gibt man einfach nslookup ohne weitere Argumente ein. Die standard Prompt wird dann durch eine spitze Klammer ersetzt. Kommandos die jetzt eingegeben werden, gehen direkt an nslookup. Dieser Modus kann per exit wieder verlassen werden.\\
Werden keine weiteren Angaben gemacht, so benutzt nslookup den standard DNS server. Mit 'lserver domain' kann der zu verwendende Server festgelegt werden. Ein query kann mit 'host' abgesetzt werden. Weitere Optionen k\"onnen in manfile nachgeschlagen werden.
%TODO research!
\begin{lstlisting}[frame=single]
niklaus@holahp1101:~$ nslookup
> server swisscom.ch
> host heise.de
\end{lstlisting}
\subsubsection{traceroute, tracepath}
Traceroute und tracepath k\"onnen die network hops bis zu einem definierten host anzeigen. Je nach Distribution sind beide oder nur eines der Programme verf\"ugbar. Traceroute bietet dabei viel mehr Optionen an als tracepath. Weitere Informationen dazu sind in der jeweiligen manpage zu finden. Die grundlegende Verwendung von traceroute ist denkbar einfach:
%TODO research!
\begin{lstlisting}[frame=single]
niklaus@holahp1101~$ traceroute www.google.com
\end{lstlisting}

\section{Piping und output Umleitung}
Die Shell kennt zwei Ausgaben, die Standard-Ausgabe (standard out) und die Error-Ausgabe (error out). Die beiden Ausgaben erfolgen getrennt und k\"onnen auch getrennt umgeleitet werden. Der Output kann in Dateien oder an andere Applikationen weitergeleitet werden.
\subsection{Output in Datei umleiten}
Der Output von Applikationen kann in eine Datei geschrieben werden. So kann man einfach Dinge dokumentieren. Beim schreiben von Scripts die automatisch ausgef\"hurt werden, ist es empfehlenswert den Output in eine Logdatei zu schreiben, damit man die Vorg\"ange sp\"ater nachvollziehen kann.
\subsubsection{Standard out}
Das Umleiten des Standard out in eine Datei ist einfach und intuitiv. Dazu wird einfach das Zeichen \textgreater, gefolgt von der Zieldatei, hinten an den Command geschrieben. Mit folgendem Kommando wird die aktuelle IP-Konfiguration von eth0 in eine Datei geschrieben:
\begin{lstlisting}[frame=single, style=shell]
niklaus@holahp1101:~$ ifconfig eth0 > eth0_config
\end{lstlisting}
Das einfache \textgreater ueberschreibt die Datei jedes Mal komplett. Das ist nicht immer gew\"unscht. Wir k\"onnen den Output auch jeweils an das Ende der Datei anh\"angen. Dazu verwenden wir den \textgreater\textgreater redirect. In folgendem Beispiel schreiben wir unter die Interface config noch die DNS Konfiguration.
\begin{lstlisting}[frame=single, style=shell]
niklaus@holahp1101:~$ ifconfig eth0 > eth0_config
niklaus@holahp1101:~$ cat /etc/resolv.conf >> eth0_config
\end{lstlisting}
In manchen F\"allen m\"ochte man den Standard out aber nicht in eine Datei schreiben, sondern einfach loswerden. Zu diesem Zweck kann man ihn in den virtuellen /dev/null Datentr\"ager umleiten. Das wird oft dann gemacht, wenn ein Task im Hintergrund laufen soll w\"ahrend man im gleichen Terminal weiterarbeiten will:
\begin{lstlisting}[frame=single, style=shell]
niklaus@holahp1101:~$ sudo apt-get update > /dev/null &
\end{lstlisting}
Der \textgreater Operator kann auch zum 'leeren' einer Datei verwendet werden:
\begin{lstlisting}[frame=single, style=shell]
niklaus@holahp1101:~$ > eth0_config
\end{lstlisting}
\subsubsection{Error Output}
Die Errors werden von Applikationen nicht in den Standard Out geschrieben, sondern in einen speziellen, den Error-, Output. Das ist n\"utzlich, da man sich beim Verarbeiten von Programm-Output nicht \"uberlegen muss, was denn geschieht wenn eine Fehlermeldung ausgegeben wird anstatt des erwarteten Outputs. Die Fehlermeldungen kann man so einfach eigens verarbeiten. Zum Umleiten des Fehleroutputs verwendet man '2\textgreater'. M\"ochte man weder vom Standard Out, noch von Fehlermeldungen gest\"ort werden, so leitet man einfach beide Outputs um.
\begin{lstlisting}[frame=single, style=shell]
niklaus@holahp1101:~$ sudo apt-get update > /dev/null 2> /dev/null &
\end{lstlisting}
\subsection{pipes}
Einer der gr\"ossten Vorteile der Shell ist, dass verschiedene Applikationen mit sogenannten Pipes verbuden/verkettet werden k\"onnen. Dadurch kann output gefiltert oder weiterverarbeitet werden. Eine vielzahl von Shell Applikationen l\"asst sich mit pipes nutzen. Ich werde hier einige typische Verwendungen aufzeigen. Die M\"oglichkeiten die sich durch Pipes ergeben sind aber nahezu unaussch\"opflich.\\
Das Zeichen um zwei Programme miteinander zu verbinden ist | , genannt pipe. Der Standard-output (das was auf der Shell zu sehen ist) wird dabei zum standard-input des Programmes hinter |.
\subsection{Filtern des outputs}
Grep kann nicht nur Dateien durchsuchen und filtern, sondern auch standard input. Dazu wird grep einfach per pipe hinten an einen anderen command geh\"angt, der zu suchende Begriff wird einfach als Parameter angeh\"angt. Ein typisches Beispiel ist die Verwendung von grep zum durchsuchen der ps Ausgabe nach einem bestimmten Prozess. Ein sehr anschauliches, wenn auch nicht besonders sinnvolles, Beispiel ist das Filtern des Outputs von cat.
\begin{lstlisting}[frame=single, style=Shell]
niklaus@holahp1101:/usr/src/linux$ cat CREDITS | grep Kroah
N: Greg Kroah-Hartman
\end{lstlisting}
Wie bereits erw\"ahnt, ist dier Command nicht besonders ellegant, da Grep die Datei auch selbst\"andig einlesen kann.
\begin{lstlisting}[frame=single, style=Shell]
grep Kroah CREDITS
\end{lstlisting}
Grep ist ein sehr m\"achtiges Tool, es ist aber nicht die einzige M\"oglichkeit und es ist nicht f\"ur alle Aufgaben geeignet. Noch weit m\"achtiger als Grep ist AWK. AWK ist aber nicht nur ein einfaches Programm, sondern eigentlich eine eigene Programmiersprache. Ich mache hier nur ein einfaches Beispiel f\"ur die Verwendung von awk. (nah, was macht das wohl? :D, Challenge for the user!)
\begin{lstlisting}[frame=single, style=Shell]
ls -lh --time-style="+%D %T" .bashrc | awk '{ print $6,$7"\t"$5"\t"$8 }'
\end{lstlisting}
\end{document}
